---
title: "2. /ptk/ uniformity - ordinal relationships"
author: "Khia A Johnson"
date: "4/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(lme4)
library(lmerTest)
library(optimx)
library(wec)
library(emmeans)
library(brms)
library(ggthemes)
library(tidybayes)

options(scipen=999)

theme_set(
  theme_clean() + 
  theme(
      legend.title = element_blank(),
      legend.text = element_text(size=8),
      legend.position = 'bottom',
      axis.title.x = element_text(size = 8, face='bold'),
      axis.title.y = element_text(size = 8, face='bold'),
      axis.text.x = element_text(size = 8),
      axis.text.y = element_text(size = 8),
      strip.text = element_text(size = 8, face='bold'),
      )
  )
```

```{r}
df <- read_csv('dfs/ptk_clean_20210602.csv')
df
```


Center VOT and standardize average phone duration
```{r}
df$vot_z <- scale(df$vot_ms, center=TRUE, scale=TRUE)
df$vot_scaled <- scale(df$vot_ms, center=FALSE, scale=TRUE)

df$apd_z <- scale(df$avg_phone_dur_ms, center=TRUE, scale=TRUE)
```

Set up and inspect weighted effect coding
```{r}
df$is_post_pausal <- as_factor(df$is_post_pausal)
contrasts(df$is_post_pausal) <- contr.wec(x=df$is_post_pausal, omitted = FALSE)
contrasts(df$is_post_pausal)

df$segment <- as_factor(df$segment)
contrasts(df$segment) <- contr.wec(x=df$segment, omitted = 'p')
contrasts(df$segment)

df$language <- as_factor(df$language)
contrasts(df$language) <-  contr.wec(x=df$language, omitted = 'Cantonese')
contrasts(df$language)
```


```{r}
df <- df %>%
  mutate(phone = as_factor(paste(str_sub(language, start = 1L, end = 3L), str_to_upper(segment), sep = '')),
         pause = is_post_pausal)

levels(df$phone) <- c('CanP', 'CanT', 'CanK', 'EngP', 'EngT', 'EngK')
```

```{r}
df %>%
  ggplot(aes(x=vot_scaled)) +
  geom_histogram()

df %>%
  ggplot(aes(x=vot_ms)) +
  geom_histogram()
```



Follows Krushke's approach from https://solomonkurz.netlify.app/post/2020-12-09-multilevel-models-and-the-index-variable-approach/ 
```{r}
get_prior(
    formula = vot_scaled ~ 0 + phone + apd_z + pause + (0 + phone | talker) + (1 | word),
    family = lognormal(),
    data = df
)
```

```{r}
m <- 
  brm(
    formula = vot_scaled ~ 0 + phone + apd_z + pause + (0 + phone | talker) + (1 | word),
    family = lognormal(),
    data = df,
    prior = c(
      # prior(lognormal(0, 1), class = b, coef = phoneCanP), # restricting to pos values given index var coding
      # prior(lognormal(0, 1), class = b, coef = phoneCanT), # note that values *scaled* but not centered
      # prior(lognormal(0, 1), class = b, coef = phoneCanK),
      # prior(lognormal(0, 1), class = b, coef = phoneEngP),
      # prior(lognormal(0, 1), class = b, coef = phoneEngT),
      # prior(lognormal(0, 1), class = b, coef = phoneEngK),
      # prior(normal(0, 1), class = b, coef = apd_z), 
      # prior(normal(0, 1), class = b, coef = pauseTRUE),
      prior(normal(0, 1), class = b),
      prior(lkj(2), class = cor) # what mcelreath does
      ),
    chains = 4, cores = 4, iter = 2000, warmup = 1000,
    file = 'fits/m.lognormal.1'
  )
```

Model checks
```{r}
mcmc_plot(m, type='rhat_hist')
mcmc_plot(m, type='neff_hist')
```

```{r}
summary(m)
```

```{r}
exp(-0.33)
```

```{r fig.height=5, fig.width=5}
posterior_samples(m) %>% 
  select(starts_with("sd")) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(x = value, y = name)) +
  stat_halfeye(.width = .95, size = 1/2) +
  scale_y_discrete(NULL, labels = ggplot2:::parse_safe)
```

Get variable names for use in later plotting
```{r}
m %>%
  get_variables %>%
  head(32)
```

```{r}
sd(df$vot_ms)
```


```{r fig.height=5, fig.width=5}
posterior_samples(m) %>% 
  select(starts_with("b_")) %>% 
  pivot_longer(everything()) %>% 
  filter(name != 'b_Intercept') %>%
  mutate(expval = exp(value)*sd(df$vot_ms)) %>%
  ggplot(aes(x = expval, y = name)) +
  stat_halfeye(.width = .95, size = 1/2) +
  scale_y_discrete(NULL, labels = ggplot2:::parse_safe)
```


```{r fig.width=10, fig.height=8}
levels(df$segment) <- c('p', 't', 'k')

df %>%
  ggplot(aes(y=vot_ms, x=segment, fill=language)) +
  geom_boxplot(alpha=0.5) +
  scale_fill_colorblind() +
  facet_wrap(~talker)
```

```{r}

```



## Frequentist model

Didn't converge -- going bayesian
```{r}
mod <- lmer(
  formula = vot_z ~ 1 + segment * language + avg_phone_dur_z + is_post_pausal + (segment * language | talker) + (1 | word),
  data = df,
  control = lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))
  #lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )
```

```{r}
# AF1 <- allFit(mod, verbose=TRUE, parallel = "multicore")
#saveRDS(AF1, 'fits/allFit_vot_uniformity.rds')
AF1 <- readRDS('fits/allFit_vot_uniformity.rds')

#There were no warnings or convergence issues with the bobyqa optimizer (or: optimx.L-BFGS-B; nloptwrap.NLOPT_LN_BOBYQA); others had "Model failed to converge with 1 negative eigenvalue" like errors

mod_r1 <- AF1$bobyqa
summary(mod_r1)
```


Ran the pairwise comparisons on the science computer, since it takes a long time (output pasted below)
```{r}
library(emmeans)
emm <- emmeans(mod_r1, pairwise ~ language | segment, confid)
# emm <- readRDS('fits/emm_vot_uniformity.rds')
summary(emm)
```
