---
title: "2. /ptk/ uniformity - ordinal relationships"
author: "Khia A Johnson"
date: "4/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(lme4)
library(lmerTest)
library(optimx)
library(wec)
library(emmeans)
library(brms)
library(ggthemes)

options(scipen=999)

theme_set(
  theme_clean() + 
  theme(
      legend.title = element_blank(),
      legend.text = element_text(size=8),
      legend.position = 'bottom',
      axis.title.x = element_text(size = 8, face='bold'),
      axis.title.y = element_text(size = 8, face='bold'),
      axis.text.x = element_text(size = 8),
      axis.text.y = element_text(size = 8),
      strip.text = element_text(size = 8, face='bold'),
      )
  )
```

```{r}
df <- read_csv('dfs/ptk_clean_20210602.csv')
df
```

```{r}
df %>%
  ggplot(aes(x=vot_ms)) + 
  geom_density()
```

Center VOT and standardize average phone duration
```{r}
df$vot_z <- scale(df$vot_ms, center=TRUE, scale=TRUE)
df$avg_phone_dur_z <- scale(df$avg_phone_dur_ms, center=TRUE, scale=TRUE)
```

Set up and inspect weighted effect coding
```{r}
df$is_post_pausal <- as_factor(df$is_post_pausal)
contrasts(df$is_post_pausal) <- contr.wec(x=df$is_post_pausal, omitted = FALSE)
contrasts(df$is_post_pausal)
# 
# df$segment <- as_factor(df$segment)
# contrasts(df$segment) <- contr.wec(x=df$segment, omitted = 'p')
# contrasts(df$segment)
# 
# df$language <- as_factor(df$language)
# contrasts(df$language) <-  contr.wec(x=df$language, omitted = 'Cantonese')
# contrasts(df$language)
```

Inspect the dataframe
```{r}
df <- df %>%
  mutate(seg = paste(language, str_to_upper(segment), sep = '_'))
```


```{r}
get_prior(
  formula = vot_ms ~ 0 + seg + is_post_pausal + avg_phone_dur_z + (0 + seg | talker) + (1|word),
  family = lognormal(),
  data = df
)
```

```{r}
m <- 
  brm(formula = vot_ms ~ 0 + seg + is_post_pausal + avg_phone_dur_z + (0 + seg | talker) + (1 | word),
      family = gaussian(),
      data = df,
      prior = prior(normal(0, 1), class = b),
      chains = 5, cores = 5, iter = 2000, warmup = 1000,
      file = 'fits/m1.v7'
  )
```


```{r}
m1.1 %>%
  spread_draws(`b_.*`, regex = TRUE) %>%
  select(b_segCantonese_K:b_avg_phone_dur_z) %>%
  pivot_longer(b_segCantonese_K:b_avg_phone_dur_z) %>%
  ggplot(aes(x=value)) +
    geom_density() +
    facet_wrap(~name)

```


```{r}
library(tidybayes)
```


```{r}
m1.1 %>%
  get_variables()

draws <- m1.1 %>%
  spread_draws(r_talker[talker,segment]) %>%
    separate(segment, into = c('language', 'phone')) %>%
    mutate(
      language = str_replace(language, 'seg', ''),
      phone = as_factor(phone))

levels(draws$phone) <- c('P', 'T', 'K')

```

```{r}
fitted
```


```{r fig.width=8, fig.height=10}
draws %>%
  ggplot(aes(y = phone, x = r_talker, color=language)) +
  stat_halfeye() +
  facet_wrap(~talker)

```


## Frequentist model

Didn't converge -- going bayesian
```{r}
mod <- lmer(
  formula = vot_z ~ 1 + segment * language + avg_phone_dur_z + is_post_pausal + (segment * language | talker) + (1 | word),
  data = df,
  control = lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))
  #lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )
```

```{r}
# AF1 <- allFit(mod, verbose=TRUE, parallel = "multicore")
#saveRDS(AF1, 'fits/allFit_vot_uniformity.rds')
AF1 <- readRDS('fits/allFit_vot_uniformity.rds')

#There were no warnings or convergence issues with the bobyqa optimizer (or: optimx.L-BFGS-B; nloptwrap.NLOPT_LN_BOBYQA); others had "Model failed to converge with 1 negative eigenvalue" like errors

mod_r1 <- AF1$bobyqa
summary(mod_r1)
```


Ran the pairwise comparisons on the science computer, since it takes a long time (output pasted below)
```{r}
library(emmeans)
emm <- emmeans(mod_r1, pairwise ~ language | segment, confid)
# emm <- readRDS('fits/emm_vot_uniformity.rds')
summary(emm)
```
