---
title: "2. /ptk/ uniformity - ordinal relationships"
author: "Khia A Johnson"
date: "4/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(lme4)
library(lmerTest)
library(optimx)
library(wec)
library(emmeans)
library(brms)
library(ggthemes)
library(tidybayes)

options(scipen=999)

theme_set(
  theme_clean() + 
  theme(
      legend.title = element_blank(),
      legend.text = element_text(size=8),
      legend.position = 'bottom',
      axis.title.x = element_text(size = 8, face='bold'),
      axis.title.y = element_text(size = 8, face='bold'),
      axis.text.x = element_text(size = 8),
      axis.text.y = element_text(size = 8),
      strip.text = element_text(size = 8, face='bold'),
      )
  )
```

```{r}
df <- read_csv('dfs/ptk_clean_20210602.csv')
df
```


Center VOT and standardize average phone duration
```{r}
df$vot_z <- scale(df$vot_ms, center=TRUE, scale=TRUE)
df$vot_scaled <- scale(df$vot_ms, center=FALSE, scale=TRUE)

df$apd_z <- scale(df$avg_phone_dur_ms, center=TRUE, scale=TRUE)
```

Set up and inspect weighted effect coding
```{r}
df$is_post_pausal <- as_factor(df$is_post_pausal)
contrasts(df$is_post_pausal) <- contr.wec(x=df$is_post_pausal, omitted = FALSE)
contrasts(df$is_post_pausal)

df$segment <- as_factor(df$segment)
contrasts(df$segment) <- contr.wec(x=df$segment, omitted = 'p')
contrasts(df$segment)

df$language <- as_factor(df$language)
contrasts(df$language) <-  contr.wec(x=df$language, omitted = 'Cantonese')
contrasts(df$language)
```

```{r}
df %>%
  ggplot(aes(x=vot_scaled)) +
  geom_histogram()

df %>%
  ggplot(aes(x=vot_ms)) +
  geom_histogram()
```

```{r}
df
```


Same model structure as before, but bayesian and lognormal
```{r}
get_prior(
  vot_scaled ~ 1 + segment * language + apd_z + is_post_pausal + (1 + segment * language | talker) + (1 | word),
  family = lognormal(),
  data = df
)
```

```{r}
m <- 
  brm(
  vot_scaled ~ 1 + segment * language + apd_z + is_post_pausal + (1 + segment * language | talker) + (1 | word),
    family = lognormal(),
    data = df,
    prior = c(
      prior(student_t(3, 0, 2.5), class = Intercept),
      prior(normal(0, 1), class = b),
      prior(lkj(2), class = cor) 
      ),
    chains = 4, cores = 4, iter = 5000, warmup = 2500,
    file = 'fits/m.lognormal.final'
  )
```


```{r}
summary(m)
```


Model checks
```{r}
mcmc_plot(m, type='rhat_hist')
mcmc_plot(m, type='neff_hist')
```


```{r }
posterior_samples(m) %>% 
  select(starts_with("sd")) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(x = value, y = name)) +
  stat_halfeye(.width = .95, size = 1/2) +
  scale_y_discrete(NULL, labels = ggplot2:::parse_safe)
```

Get variable names for use in later plotting
```{r}
as_tibble(get_variables(m))
```

```{r fig.height=10, fig.width=5}
posterior_samples(m) %>% 
  select(starts_with("r_talker")) %>% 
  pivot_longer(everything()) %>% 
  separate(name, into = c('talker', 'parameter'), sep = ',') %>%
  mutate(talker = str_replace(talker, 'r_talker\\[', ''),
         parameter = str_replace(parameter, '\\]','')) %>%
  
  ggplot(aes(x = value, y = talker, fill = parameter)) +
  stat_halfeye(.width = .95, size = 1/2, alpha=0.5) +
  scale_y_discrete(NULL, labels = ggplot2:::parse_safe) +
  scale_fill_colorblind()
```



```{r}
posterior_samples(m) %>% 
  select(starts_with("b_")) %>% 
  pivot_longer(everything()) %>% 
  filter(name != 'b_Intercept') %>%
  ggplot(aes(x = value, y = name)) +
  stat_halfeye(.width = .95, size = 1/2) +
  scale_y_discrete(NULL, labels = ggplot2:::parse_safe)
```


```{r fig.width=10, fig.height=8}
levels(df$segment) <- c('p', 't', 'k')

df %>%
  ggplot(aes(y=vot_ms, x=segment, fill=language)) +
  geom_boxplot(alpha=0.5) +
  scale_fill_colorblind() +
  facet_wrap(~talker)
```













## Frequentist model

Didn't converge -- going bayesian
```{r}
mod <- lmer(
  formula = vot_z ~ 1 + segment * language + avg_phone_dur_z + is_post_pausal + (segment * language | talker) + (1 | word),
  data = df,
  control = lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))
  #lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )
```

```{r}
# AF1 <- allFit(mod, verbose=TRUE, parallel = "multicore")
#saveRDS(AF1, 'fits/allFit_vot_uniformity.rds')
AF1 <- readRDS('fits/allFit_vot_uniformity.rds')

#There were no warnings or convergence issues with the bobyqa optimizer (or: optimx.L-BFGS-B; nloptwrap.NLOPT_LN_BOBYQA); others had "Model failed to converge with 1 negative eigenvalue" like errors

mod_r1 <- AF1$bobyqa
summary(mod_r1)
```


Ran the pairwise comparisons on the science computer, since it takes a long time (output pasted below)
```{r}
library(emmeans)
emm <- emmeans(mod_r1, pairwise ~ language | segment, confid)
# emm <- readRDS('fits/emm_vot_uniformity.rds')
summary(emm)
```
