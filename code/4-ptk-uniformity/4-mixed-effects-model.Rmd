---
title: "2. /ptk/ uniformity - ordinal relationships"
author: "Khia A Johnson"
date: "4/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(lme4)
library(lmerTest)
library(optimx)
library(wec)
library(emmeans)
library(brms)
library(ggthemes)

options(scipen=999)

theme_set(
  theme_clean() + 
  theme(
      legend.title = element_blank(),
      legend.text = element_text(size=8),
      legend.position = 'bottom',
      axis.title.x = element_text(size = 8, face='bold'),
      axis.title.y = element_text(size = 8, face='bold'),
      axis.text.x = element_text(size = 8),
      axis.text.y = element_text(size = 8),
      strip.text = element_text(size = 8, face='bold'),
      )
  )
```

```{r}
df <- read_csv('dfs/ptk_clean_20210602.csv')
df
```

```{r}
df %>%
  ggplot(aes(x=vot_ms)) + 
  geom_density()
```

Center VOT and standardize average phone duration
```{r}
df$vot_z <- scale(df$vot_ms, center=TRUE, scale=TRUE)
df$avg_phone_dur_z <- scale(df$avg_phone_dur_ms, center=TRUE, scale=TRUE)
```

Set up and inspect weighted effect coding
```{r}
df$is_post_pausal <- as_factor(df$is_post_pausal)
contrasts(df$is_post_pausal) <- contr.wec(x=df$is_post_pausal, omitted = FALSE)
contrasts(df$is_post_pausal)

df$segment <- as_factor(df$segment)
contrasts(df$segment) <- contr.wec(x=df$segment, omitted = 'p')
contrasts(df$segment)

df$language <- as_factor(df$language)
contrasts(df$language) <-  contr.wec(x=df$language, omitted = 'Cantonese')
contrasts(df$language)
```

Inspect the dataframe
```{r}
df <- df %>%
  mutate(seg = as_factor(paste(language, str_to_upper(segment), sep = '_')))

levels(df$seg) <- c('Cantonese_P', 'Cantonese_T', 'Cantonese_K', 'English_P', 'English_T', 'English_K')

contrasts(df$seg)

```

Follows Krushke's approach from https://solomonkurz.netlify.app/post/2020-12-09-multilevel-models-and-the-index-variable-approach/ 
```{r}
get_prior(
    formula = vot_z ~ 0 + seg + avg_phone_dur_z + is_post_pausal + (0 + seg | talker) + (1 | word),
    family = gaussian(),
    data = df
)
```

fit2 <- 
  brm(data = d, 
      family = binomial,
      pulled_left | trials(1) ~ 1 + (1 | actor) + (1 | treatment) + (1 | actor:treatment),
      prior = c(prior(normal(0, 1), class = Intercept),
                prior(exponential(1), class = sd)),
      cores = 4, seed = 1)

```{r}
m <- 
  brm(
    formula = vot_ms ~ 0 + seg + avg_phone_dur_ms + is_post_pausal + (0 + seg | talker) + (1 | word),
    family = gaussian(),
    data = df,
    prior = prior(normal(0, 1), class = b),
    chains = 5, cores = 5, iter = 2000, warmup = 1000,
    file = 'fits/m.gaussian.1'
  )
summary(m)
```

```{r}
posterior_samples(m) %>% 
  select(starts_with("sd")) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(x = value, y = name)) +
  stat_halfeye(.width = .95, size = 1/2) +
  scale_y_discrete(NULL, labels = ggplot2:::parse_safe) +
  xlab("marginal posterior (log-odds scale)") +
  theme(axis.text.y = element_text(hjust = 0),
        axis.ticks.y = element_blank(),
        panel.grid = element_blank())
```


```{r}
m1.1 %>%
  spread_draws(`b_.*`, regex = TRUE) %>%
  select(b_segCantonese_K:b_avg_phone_dur_z) %>%
  pivot_longer(b_segCantonese_K:b_avg_phone_dur_z) %>%
  ggplot(aes(x=value)) +
    geom_density() +
    facet_wrap(~name)

```


```{r}
library(tidybayes)
```


```{r}
m %>%
  get_variables()
```


```{r}
draws <- m1.1 %>%
  spread_draws(r_talker[talker,segment]) %>%
    separate(segment, into = c('language', 'phone')) %>%
    mutate(
      language = str_replace(language, 'seg', ''),
      phone = as_factor(phone))

levels(draws$phone) <- c('P', 'T', 'K')

```

```{r}
fitted
```


```{r fig.width=8, fig.height=10}
draws %>%
  ggplot(aes(y = phone, x = r_talker, color=language)) +
  stat_halfeye() +
  facet_wrap(~talker)

```


## Frequentist model

Didn't converge -- going bayesian
```{r}
mod <- lmer(
  formula = vot_z ~ 1 + segment * language + avg_phone_dur_z + is_post_pausal + (segment * language | talker) + (1 | word),
  data = df,
  control = lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))
  #lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )
```

```{r}
# AF1 <- allFit(mod, verbose=TRUE, parallel = "multicore")
#saveRDS(AF1, 'fits/allFit_vot_uniformity.rds')
AF1 <- readRDS('fits/allFit_vot_uniformity.rds')

#There were no warnings or convergence issues with the bobyqa optimizer (or: optimx.L-BFGS-B; nloptwrap.NLOPT_LN_BOBYQA); others had "Model failed to converge with 1 negative eigenvalue" like errors

mod_r1 <- AF1$bobyqa
summary(mod_r1)
```


Ran the pairwise comparisons on the science computer, since it takes a long time (output pasted below)
```{r}
library(emmeans)
emm <- emmeans(mod_r1, pairwise ~ language | segment, confid)
# emm <- readRDS('fits/emm_vot_uniformity.rds')
summary(emm)
```
