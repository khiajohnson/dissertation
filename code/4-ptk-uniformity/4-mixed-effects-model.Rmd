---
title: "2. /ptk/ uniformity - ordinal relationships"
author: "Khia A Johnson"
date: "4/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(lme4)
library(lmerTest)
library(optimx)
library(wec)
library(emmeans)
library(brms)
library(ggthemes)
library(tidybayes)

options(scipen=999)

theme_set(
  theme_clean() + 
  theme(
      legend.title = element_blank(),
      legend.text = element_text(size=8),
      legend.position = 'bottom',
      axis.title.x = element_text(size = 8, face='bold'),
      axis.title.y = element_text(size = 8, face='bold'),
      axis.text.x = element_text(size = 8),
      axis.text.y = element_text(size = 8),
      strip.text = element_text(size = 8, face='bold'),
      )
  )
```

```{r}
df <- read_csv('dfs/ptk_clean_20210602.csv')
df
```

```{r}
df %>%
  ggplot(aes(x=vot_ms, color = language, fill=language)) + 
  geom_histogram(alpha=0.5)  +
  facet_grid(~segment)
```

Center VOT and standardize average phone duration
```{r}
df$vot_z <- scale(df$vot_ms, center=TRUE, scale=TRUE)
df$avg_phone_dur_z <- scale(df$avg_phone_dur_ms, center=TRUE, scale=TRUE)
```

Set up and inspect weighted effect coding
```{r}
df$is_post_pausal <- as_factor(df$is_post_pausal)
contrasts(df$is_post_pausal) <- contr.wec(x=df$is_post_pausal, omitted = FALSE)
contrasts(df$is_post_pausal)

df$segment <- as_factor(df$segment)
contrasts(df$segment) <- contr.wec(x=df$segment, omitted = 'p')
contrasts(df$segment)

df$language <- as_factor(df$language)
contrasts(df$language) <-  contr.wec(x=df$language, omitted = 'Cantonese')
contrasts(df$language)
```

Follows Krushke's approach from https://solomonkurz.netlify.app/post/2020-12-09-multilevel-models-and-the-index-variable-approach/ 
```{r}
get_prior(
    formula = vot_ms ~ 1 + segment * language + avg_phone_dur_z + is_post_pausal + (1 + segment * language | talker) + (1 | word),
    family = lognormal(),
    data = df
)
```

```{r}
m <- 
  brm(
    formula = vot_ms ~ 1 + segment * language + avg_phone_dur_z + is_post_pausal + (1 + segment * language | talker) + (1 | word),
    family = gaussian(),
    data = df,
    prior = c(
      prior(normal(4, 0.5), class = Intercept), # in log ms, this restrict the mean mostly to the 20 to 148 ms range
      prior(normal(0, 1), class = b), # everything else is normalized
      prior(lkj(2), class = cor) # what mcelreath does
      ),
    chains = 4, cores = 4, iter = 5000, warmup = 2500,
    file = 'fits/m.gaussian.3'
  )
```

```{r fig.height=8}
posterior_samples(m) %>% 
  select(starts_with("sd")) %>% 
  pivot_longer(everything()) %>% 
  ggplot(aes(x = value, y = name)) +
  stat_halfeye(.width = .95, size = 1/2) +
  scale_y_discrete(NULL, labels = ggplot2:::parse_safe) +
  xlab("marginal posterior (log-odds scale)") +
  theme(axis.text.y = element_text(hjust = 0),
        axis.ticks.y = element_blank(),
        panel.grid = element_blank())
```

Get variable names for use in later plotting
```{r}
m %>%
  get_variables %>%
  head(100)
```

Model checks
```{r}
mcmc_plot(m, type='rhat_hist')
mcmc_plot(m, type='neff_hist')
```

```{r}
plot(m)
```

```{r}
m
```



## Frequentist model

Didn't converge -- going bayesian
```{r}
mod <- lmer(
  formula = vot_z ~ 1 + segment * language + avg_phone_dur_z + is_post_pausal + (segment * language | talker) + (1 | word),
  data = df,
  control = lmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))
  #lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
  )
```

```{r}
# AF1 <- allFit(mod, verbose=TRUE, parallel = "multicore")
#saveRDS(AF1, 'fits/allFit_vot_uniformity.rds')
AF1 <- readRDS('fits/allFit_vot_uniformity.rds')

#There were no warnings or convergence issues with the bobyqa optimizer (or: optimx.L-BFGS-B; nloptwrap.NLOPT_LN_BOBYQA); others had "Model failed to converge with 1 negative eigenvalue" like errors

mod_r1 <- AF1$bobyqa
summary(mod_r1)
```


Ran the pairwise comparisons on the science computer, since it takes a long time (output pasted below)
```{r}
library(emmeans)
emm <- emmeans(mod_r1, pairwise ~ language | segment, confid)
# emm <- readRDS('fits/emm_vot_uniformity.rds')
summary(emm)
```
